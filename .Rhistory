heatmap(as.matrix(Auto_rm[1:6]), Colv = NA, Rowv = NA, scale="column")
heatmap(as.matrix(Auto_rm[1:6]), scale="column", col = cm.colors(256))
cor(Auto_rm[1:6])>.75
pairs(Auto_rm[1:6])
plot(lm(mpg~ ., data = Auto_rm[1:6]))
plot(lm(cylinders~ ., data = Auto_rm[1:6]))
plot(lm(displacement~ ., data = Auto_rm[1:6]))
plot(lm(horsepower~ ., data = Auto_rm[1:6]))
plot(lm(weight~ ., data = Auto_rm[1:6]))
plot(lm(acceleration~ ., data = Auto_rm[1:6]))
plot(lm(year~ ., data = Auto_rm[1:6]))
plot(lm(origin~ ., data = Auto_rm[1:6]))
pairs(Auto_rm[1:6])
plot(lm(mpg~ ., data = Auto_rm[1:6]))
plot(lm(cylinders~ ., data = Auto_rm[1:6]))
plot(lm(displacement~ ., data = Auto_rm[1:6]))
plot(lm(horsepower~ ., data = Auto_rm[1:6]))
plot(lm(weight~ ., data = Auto_rm[1:6]))
plot(lm(acceleration~ ., data = Auto_rm[1:6]))
cor(Auto_rm[1:6])
cor(Auto_rm[1:6])>.75
#I created a heat map but it did not end up being useful
#heatmap(as.matrix(Auto_rm[1:6]), scale="column", col = cm.colors(256))
lm(mpg~.,data=Auto_rm[1:6])
summary(lm(mpg~.,data=Auto_rm[1:6]))
plot(lm(mpg~.,data=Auto_rm[1:6]))
Yhat_salary = (20*GPA) + (.07*IQ)+(35*GENDER)+(.01*GPA)+(-10*(GPA*GENDER))
IQ=110
GPA=4
GENDER=1
Yhat_salary = (20*GPA) + (.07*IQ)+(35*GENDER)+(.01*GPA)+(-10*(GPA*GENDER))
Yhat_salary
Yhat_salary = (20*GPA) + (.07*IQ)+(35*GENDER)+(.01*GPA*IQ)+(-10*(GPA*GENDER))
Yhat_salary
Yhat_salary = (20*GPA) + (.07*IQ)+(35*GENDER)+(.01*GPA*IQ)+(-10*(GPA*GENDER))
Yhat_salary
Yhat_salary = (20*GPA) + (.07*IQ)+(35*GENDER)+(.01*GPA*IQ)+(-10*(GPA*GENDER))
Yhat_salary
Yhat_salary = (20*GPA) + (.07*IQ)+(35*GENDER)+(.01*GPA*IQ)+(-10*(GPA*GENDER))
Yhat_salary
Yhat_salary = (20*GPA) + (.07*IQ)+(35*GENDER)+(.01*GPA*IQ)+(-10*(GPA*GENDER))+50
Yhat_salary
print(Yhat_salary)
set.seed(1)
x1=runif (100)
x2=0.5*x1+rnorm (100)/10
y=2+2*x1+0.3*x2+rnorm (100)
cor(x1,x2)
plot(x1,x2)
lm(y~x1+x2)
print(lm(y~x1+x2))
summary(lm(y~x1+x2))
summary(lm(y~x1))
summary(lm(y~x2))
x1=c(x1, 0.1)
x2=c(x2, 0.8)
y=c(y,6)
summary(lm(y~x2))
summary(lm(y~x1+x2))
resid_matrix = matrix(rep(0,5000), nrow=1000)
for(i in 1:1000){
n = 100
x = rnorm(n)
y = 5 + 2 * x + rnorm(n, 0.5)
for(j in 1:5){
mat[i,j] = sum(residuals(lm(y ~ poly(x,j,raw=T)))^2)
}
}
for(i in 1:1000){
n = 100
x = rnorm(n)
y = 5 + 2 * x + rnorm(n, 0.5)
for(j in 1:5){
resid_matrix[i,j] = sum(residuals(lm(y ~ poly(x,j,raw=T)))^2)
}
}
resid_matrix
boxplot(resid_matrix)
rm(list=ls())
knitr::opts_chunk$set(echo = TRUE)
library(ISLR)
library(knitr)
include_graphics('./Kaggle screen shot STTT 481.png')
include_graphics('./swirl_hw_1_Ex1.PNG')
include_graphics('./swirl_hw_1_Ex2.PNG')
include_graphics('./swirl_hw_1_Ex3.PNG')
include_graphics('./swirl_hw_1_Ex4.PNG')
include_graphics('./swirl_hw_1_Ex5.PNG')
include_graphics('./swirl_hw_1_Ex6.PNG')
include_graphics('./swirl_hw_1_Ex7.PNG')
include_graphics('./swirl_hw_1_Ex8.PNG')
include_graphics('./swirl_hw_1_Ex9.PNG')
include_graphics('./swirl_hw_1_Ex10.PNG')
include_graphics('./swirl_hw_1_Ex11.PNG')
include_graphics('./swirl_hw_1_Ex12.PNG')
include_graphics('./swirl_hw_1_Ex13.PNG')
include_graphics('./swirl_hw_1_Ex14.PNG')
include_graphics('./swirl_hw_1_Ex15.PNG')
#Let's first replicate the df in question #7 from section 2.4
X1 <- c(0,2,0,0,-1,1)
X2 <- c(3,0,1,1,0,1)
X3 <- c(0,0,3,2,1,1)
Y <- c("Red","Red","Red","Green","Green","Red")
training_data <- data.frame(X1,X2,X3,Y)
training_data
#(a)
college <- read.csv("College.csv",header = TRUE)
college
#(b)
#Look at data using fix()
fix(college)
#Try the following commands
rownames(college)=college[,1]
fix(college)
college
college=college[,-1]
fix(college)
#Display college, see row.names is set and that extra (prior) column is removed
college
#(c) i.
#Use summary function on data set 'college'
summary(college)
#(c) ii.
#Use pairs function to create scatterplot matrix of first 10 columns of data set 'college'
pairs(college[1:10])
#(c) iii.
boxplot(college$Outstate, college$Private)
#(c) iv.
#Creates a vector of "No"'s dependant on the number of rows in the table
Elite=rep("No",nrow(college))
#Sets the values with a percent of over 50% to be a string "Yes"
Elite[college$Top10perc>50]="Yes"
#Coded "Elite" as a factory (aka category or enumerated type)
Elite=as.factor(Elite)
#Adds 'Elite' column to data set 'college'
college <- data.frame(college ,Elite)
college
#Run summary function on cllege and ensure Eliste is contained
summary(college)
#Get Count of Elite Colleges
number_of_elite <- sum(college$Elite=="Yes")
#Get Percent of Colleges Elite
percent_of_elite <- number_of_elite / (length(college$Elite))
#Boxplot of Out of State vs. Elise
boxplot(college$Outstate,college$Elite)
#(c) v.
#Histograms for College$P.Undergrad
#Divide window into  2x2 matrix
par(mfrow=c(2,2))
#Produce 4 histograms with differing numbers of bins (designated by 'break' parameter)
hist(College$P.Undergrad, breaks= 2 )
hist(College$P.Undergrad, breaks= 6 )
hist(College$P.Undergrad, breaks= 9 )
hist(College$P.Undergrad, breaks= 45 )
#(c) v.
#Histograms for College$Room.Board
#Divide window into  2x2 matrix
par(mfrow=c(2,2))
#Produce 4 histograms with differing numbers of bins (designated by 'break' parameter)
hist(College$Room.Board, breaks= 2 )
hist(College$Room.Board, breaks= 6 )
hist(College$Room.Board, breaks= 9 )
hist(College$Room.Board, breaks= 45 )
#(c) v.
#Histograms for College$Books
#Divide window into  2x2 matrix
par(mfrow=c(2,2))
#Produce 4 histograms with differing numbers of bins (designated by 'break' parameter)
hist(College$Books, breaks= 2 )
hist(College$Books, breaks= 6 )
hist(College$Books, breaks= 9 )
hist(College$Books, breaks= 45 )
#(c) vi.
#This did not end up being useful as there are too many variables
pairs(College)
College_Private = College[College$Private == 'Yes',]
College_Public = College[College$Private == 'No',]
#Create histograms to compare college cost
par(mfrow=c(2,2))
hist(College_Private$Books)
hist(College_Public$Books)
hist(College_Private$Room.Board)
hist(College_Public$Room.Board)
#(c) vi.
avg_g_rate_priv <- mean(College_Private$Grad.Rate)
avg_g_rate_pub <- mean(College_Public$Grad.Rate)
t.test(College_Private$Grad.Rate,College_Public$Grad.Rate)
#9
#View data and remove columns with missing data points
Auto
#Removes any rows with a missing data point
Auto_rm <- na.omit(Auto)
Auto_rm
#View all variables using summary function
summary(Auto_rm)
#Create a vector of all the quantitative variables
quant_vars <- c("mpg","cylinders","displacement","horsepower","weight","acceleration")
#Create a vector of all the qualitative variables
qual_vars <- c("name","year","origin",NA,NA,NA)
#Create and display columns containing quant_vars and qual_vars (quantitative variables and qualitative variables respectively)
Variable_Type <- data.frame(quant_vars,qual_vars)
Variable_Type
#Calculates range of all quantitative variables variables
range(Auto_rm$mpg)
range(Auto_rm$cylinders)
range(Auto_rm$displacement)
range(Auto_rm$horsepower)
range(Auto_rm$weight)
range(Auto_rm$acceleration)
#(c)
#Calc mean and sd of mpg
mean(Auto_rm$mpg)
sd(Auto_rm$mpg)
#Calc mean and sd of cylinders
mean(Auto_rm$cylinders)
sd(Auto_rm$cylinders)
#Calc mean and sd of displacement
mean(Auto_rm$displacement)
sd(Auto_rm$displacement)
#Calc mean and sd of horsepower
mean(Auto_rm$horsepower)
sd(Auto_rm$horsepower)
#Calc mean and sd of weight
mean(Auto_rm$weight)
sd(Auto_rm$weight)
#Calc mean and sd of acceleration
mean(Auto_rm$acceleration)
sd(Auto_rm$acceleration)
#(d)
#Create  data set of rows 10 - 85 of 'Auto_rm'
Auto_rm2 <- Auto_rm[c(-10:-85),]
#Display new data set 'Auto_rm2'
Auto_rm2
#Returns means of key quantitative columns
colMeans(Auto_rm2[1:6])
sapply(Auto_rm2[1:6], sd)
sapply(Auto_rm2[1:6], range)
pairs(Auto_rm[1:6])
plot(lm(mpg~ ., data = Auto_rm[1:6]))
plot(lm(cylinders~ ., data = Auto_rm[1:6]))
plot(lm(displacement~ ., data = Auto_rm[1:6]))
plot(lm(horsepower~ ., data = Auto_rm[1:6]))
plot(lm(weight~ ., data = Auto_rm[1:6]))
plot(lm(acceleration~ ., data = Auto_rm[1:6]))
cor(Auto_rm[1:6])
cor(Auto_rm[1:6])>.75
#I created a heat map but it did not end up being useful
#heatmap(as.matrix(Auto_rm[1:6]), scale="column", col = cm.colors(256))
lm(mpg~.,data=Auto_rm[1:6])
summary(lm(mpg~.,data=Auto_rm[1:6]))
plot(lm(mpg~.,data=Auto_rm[1:6]))
IQ=110
GPA=4
GENDER=1
Yhat_salary = (20*GPA) + (.07*IQ)+(35*GENDER)+(.01*GPA*IQ)+(-10*(GPA*GENDER))+50
print(Yhat_salary)
resid_matrix = matrix(rep(0,5000), nrow=1000)
for(i in 1:1000){
n = 100
x = rnorm(n)
y = 5 + 2 * x + rnorm(n, 0.5)
for(j in 1:5){
resid_matrix[i,j] = sum(residuals(lm(y ~ poly(x,j,raw=T)))^2)
}
}
boxplot(resid_matrix)
#(a)
#Summarizes
summary(Auto_rm)
#Creates matrix of scatter plots containing all variables in data set
pairs(Auto_rm)
#(b)
#create matrix of correlations, excluding last name columns
pairs(cor(Auto_rm[1:8]))
model.lm1 <- lm(mpg~cylinders+displacement+horsepower+weight+acceleration+year+origin, data = Auto_rm)
summary(model.lm1)
plot(model.lm1)
model.lm2 <- lm(mpg~cylinders*displacement*horsepower*weight*acceleration*year*origin, data = Auto_rm)
summary(model.lm2)
#Model taking into account my intuition and prior knowledge of the data set
model.lm2 <- lm(mpg~cylinders+displacement+horsepower+weight+acceleration+year+origin+ year:mpg+year:horsepower, data = Auto_rm)
#Model taking into account my intuition and prior knowledge of the data set
model.lm3 <- lm(mpg~cylinders+displacement+horsepower+weight+acceleration+year+origin+ year:mpg+year:horsepower, data = Auto_rm)
summary(model.lm3)
model.lm2 <- lm(mpg~cylinders*displacement*horsepower*weight*acceleration*year*origin, data = Auto_rm)
summary(model.lm2)
model.lm3 <- lm(log(mpg)~cylinders+displacement+horsepower+weight+acceleration+year+origin, data = Auto_rm)
summary(model.lm3)
model.lm4 <- lm(sqrt(mpg)~cylinders+displacement+horsepower+weight+acceleration+year+origin, data = Auto_rm)
summary(model.lm4)
model.lm5 <- lm(mpg~cylinders+displacement+horsepower+weight+(acceleration*year)^2+origin, data = Auto_rm)
summary(model.lm5)
Carseats
Carseats_Model1 <- lm(Sales~Price+Urban+US, data = Carseats)
summary(Carseats_Model1)
Carseats
summary(Carseats_Model1)
Carseats_Model2 <- lm(Sales~Price+US, data = Carseats)
summary(Carseats_Model2)
confint(Carseats_Model2)
plot(Carseats_Model2)
set.seed(1)
x=rnorm (100)
y=2*x+rnorm (100)
lm(y~x)
lm(y~x - 1)
lm(y~x +0)
summary(lm(y~x +0))
summary(lm(y~x +0))
summary(lm(y~x))
t_new <- sqrt(n - 1)*(x %*% y)/sqrt(sum(x^2) * sum(y^2) - (x %*% y)^2)
t_new
summary(lm(y~x))
print(summary(lm(y~x)))
print(summary(lm(y~x)))
print(summary(lm(x~y)))
setwd("C:/Users/sam/Desktop/STT481_Personal_Work")
rm(list=ls())
knitr::opts_chunk$set(echo = TRUE)
library(ISLR)
data("Weekly")
head(Weekly)
pairs(Weekly)
print(n)
n <- length(Weekly)
print(n)
n <- nrow(Weekly)
print(n)
n <- nrow(Weekly)
print(n)
for(i in n){
print(i)
}
n_vec <- seq(1,n, by=1)
for(i in n_vec){
print(i)
}
Weekly(-2)
Weekly[-2]
Weekly[-2,]
glm(Direction~Lag1+Lag2, data = Weekly_working_df, family = "binomial")
glm(Direction~Lag1+Lag2, data = Weekly, family = "binomial")
summary(glm(Direction~Lag1+Lag2, data = Weekly, family = "binomial"))
predict(x,Weekly,type="response")
x <- glm(Direction~Lag1+Lag2, data = Weekly, family = "binomial")
predict(x,Weekly,type="response")
x <- glm(Direction~Lag1+Lag2, data = Weekly[-2,], family = "binomial")
predict(x,Weekly,type="response")
predict(x,Weekly,type="response")[2]
tracking_df <- data.frame(matrix(ncol = 2, nrow = n_vec))
tracking_df
tracking_df$X1 <- n_vec
tracking_df <- data.frame(matrix(ncol = 2, nrow = n))
tracking_df$X1 <- n_vec
tracking_df
tracking_df[1] <- "Observation"
tracking_df$X1 <- n_vec
tracking_df[1] <- "Observation"
tracking_df$Observation <- n_vec
tracking_df
tracking_df <- data.frame(matrix(ncol = 2, nrow = n))
names(tracking_df)[1] <- "Observation"
tracking_df$Observation <- n_vec
tracking_df
names(tracking_df)[2] <- "Predicted_Prob_Correct"
tracking_df
tracking_df <- data.frame(matrix(ncol = 3, nrow = n))
names(tracking_df)[1] <- "Observation"
tracking_df$Observation <- n_vec
names(tracking_df)[2] <- "Predicted_Prob_Correct_Model_ii"
tracking_df
names(tracking_df)[2] <- "Predicted_Prob_Correct_Model_i"
names(tracking_df)[3] <- "Predicted_Prob_Correct_Model_ii"
tracking_df
i_list <- []
n <- nrow(Weekly) # Number observations in data set
n_vec <- seq(1,n, by=1) # Fixed vector
#Initialize empty vectors to fill with model results (0 or 1)
i_list <- vector()
ii_list <- vector()
tracking_df <- data.frame(matrix(ncol = 3, nrow = n))
names(tracking_df)[1] <- "Observation"
tracking_df$Observation <- n_vec
names(tracking_df)[2] <- "Predicted_Prob_Correct_Model_i"
names(tracking_df)[3] <- "Predicted_Prob_Correct_Model_ii"
model_calc <- function(dataframe){
for(i in n_vec){
Weekly_working_df <- Weekly[-i,] # Create subset of data removing ith row
logit_model_i_weekly_sub <- glm(Direction~Lag1+Lag2, data = Weekly_working_df, family = "binomial")
logit_model_ii_weekly_sub <- glm(Direction~Lag1+Lag2+I(Lag1^2)+I(Lag2^2), data = Weekly_working_df, family = "binomial")
posterior_prob_i <-  predict(logit_model_i_weekly_sub,Weekly,type="response")[i] # Calculate posterior probability of market movement on ith observation
posterior_prob_ii <- predict(logit_model_ii_weekly_sub,Weekly,type="response")[i] # Calculate posterior probability of market movement on ith observation
if(posterior_prob_i>.95){
i_list <- append(i_list,2)
}
if(posterior_prob_ii>.95){
ii_list <- append(ii_list,2)
}
}
}
n <- nrow(Weekly) # Number observations in data set
n_vec <- seq(1,n, by=1) # Fixed vector
#Initialize empty vectors to fill with model results (0 or 1)
i_list <- vector()
ii_list <- vector()
tracking_df <- data.frame(matrix(ncol = 3, nrow = n))
names(tracking_df)[1] <- "Observation"
tracking_df$Observation <- n_vec
names(tracking_df)[2] <- "Predicted_Prob_Correct_Model_i"
names(tracking_df)[3] <- "Predicted_Prob_Correct_Model_ii"
model_calc <- function(dataframe){
for(i in n_vec){
Weekly_working_df <- Weekly[-i,] # Create subset of data removing ith row
logit_model_i_weekly_sub <- glm(Direction~Lag1+Lag2, data = Weekly_working_df, family = "binomial")
logit_model_ii_weekly_sub <- glm(Direction~Lag1+Lag2+I(Lag1^2)+I(Lag2^2), data = Weekly_working_df, family = "binomial")
posterior_prob_i <-  predict(logit_model_i_weekly_sub,Weekly,type="response")[i] # Calculate posterior probability of market movement on ith observation
posterior_prob_ii <- predict(logit_model_ii_weekly_sub,Weekly,type="response")[i] # Calculate posterior probability of market movement on ith observation
if(posterior_prob_i>.0){
i_list <- append(i_list,2)
}
if(posterior_prob_ii>.0){
ii_list <- append(ii_list,2)
}
}
}
n <- nrow(Weekly) # Number observations in data set
n_vec <- seq(1,n, by=1) # Fixed vector
#Initialize empty vectors to fill with model results (0 or 1)
i_list <- vector()
ii_list <- vector()
tracking_df <- data.frame(matrix(ncol = 3, nrow = n))
names(tracking_df)[1] <- "Observation"
tracking_df$Observation <- n_vec
names(tracking_df)[2] <- "Predicted_Prob_Correct_Model_i"
names(tracking_df)[3] <- "Predicted_Prob_Correct_Model_ii"
model_calc <- function(dataframe){
for(i in n_vec){
Weekly_working_df <- Weekly[-i,] # Create subset of data removing ith row
logit_model_i_weekly_sub <- glm(Direction~Lag1+Lag2, data = Weekly_working_df, family = "binomial")
logit_model_ii_weekly_sub <- glm(Direction~Lag1+Lag2+I(Lag1^2)+I(Lag2^2), data = Weekly_working_df, family = "binomial")
posterior_prob_i <-  predict(logit_model_i_weekly_sub,Weekly,type="response")[i] # Calculate posterior probability of market movement on ith observation
posterior_prob_ii <- predict(logit_model_ii_weekly_sub,Weekly,type="response")[i] # Calculate posterior probability of market movement on ith observation
if(posterior_prob_i>.95){
i_list <- append(i_list,2)
}
if(posterior_prob_ii>.95){
ii_list <- append(ii_list,2)
}
}
}
model_calc(Weekly)
6+6
model_calc <- function(dataframe){
for(i in n_vec[1:5]){
Weekly_working_df <- Weekly[-i,] # Create subset of data removing ith row
logit_model_i_weekly_sub <- glm(Direction~Lag1+Lag2, data = Weekly_working_df, family = "binomial")
logit_model_ii_weekly_sub <- glm(Direction~Lag1+Lag2+I(Lag1^2)+I(Lag2^2), data = Weekly_working_df, family = "binomial")
posterior_prob_i <-  predict(logit_model_i_weekly_sub,Weekly,type="response")[i] # Calculate posterior probability of market movement on ith observation
posterior_prob_ii <- predict(logit_model_ii_weekly_sub,Weekly,type="response")[i] # Calculate posterior probability of market movement on ith observation
if(posterior_prob_i>.95){
i_list <- append(i_list,2)
}
if(posterior_prob_ii>.95){
ii_list <- append(ii_list,2)
}
}
}
model_calc(Weekly)
n <- nrow(Weekly) # Number observations in data set
n_vec <- seq(1,n, by=1) # Fixed vector
#Initialize empty vectors to fill with model results (0 or 1)
i_list <- vector()
ii_list <- vector()
tracking_df <- data.frame(matrix(ncol = 3, nrow = n))
names(tracking_df)[1] <- "Observation"
tracking_df$Observation <- n_vec
names(tracking_df)[2] <- "Predicted_Prob_Correct_Model_i"
names(tracking_df)[3] <- "Predicted_Prob_Correct_Model_ii"
model_calc <- function(dataframe){
for(i in n_vec[1:5]){
Weekly_working_df <- Weekly[-i,] # Create subset of data removing ith row
logit_model_i_weekly_sub <- glm(Direction~Lag1+Lag2, data = Weekly_working_df, family = "binomial")
logit_model_ii_weekly_sub <- glm(Direction~Lag1+Lag2+I(Lag1^2)+I(Lag2^2), data = Weekly_working_df, family = "binomial")
posterior_prob_i <-  predict(logit_model_i_weekly_sub,Weekly,type="response")[i] # Calculate posterior probability of market movement on ith observation
posterior_prob_ii <- predict(logit_model_ii_weekly_sub,Weekly,type="response")[i] # Calculate posterior probability of market movement on ith observation
if(posterior_prob_i>.95){
i_list <- append(i_list,2)
}
if(posterior_prob_ii>.95){
ii_list <- append(ii_list,2)
}
}
}
model_calc(Weekly)
model_calc(Weekly)
model_calc <- function(Weekly){
for(i in n_vec[1:5]){
Weekly_working_df <- Weekly[-i,] # Create subset of data removing ith row
logit_model_i_weekly_sub <- glm(Direction~Lag1+Lag2, data = Weekly_working_df, family = "binomial")
logit_model_ii_weekly_sub <- glm(Direction~Lag1+Lag2+I(Lag1^2)+I(Lag2^2), data = Weekly_working_df, family = "binomial")
posterior_prob_i <-  predict(logit_model_i_weekly_sub,Weekly,type="response")[i] # Calculate posterior probability of market movement on ith observation
posterior_prob_ii <- predict(logit_model_ii_weekly_sub,Weekly,type="response")[i] # Calculate posterior probability of market movement on ith observation
if(posterior_prob_i>.95){
i_list <- append(i_list,1)
}
if(posterior_prob_ii>.95){
ii_list <- append(ii_list,1)
}
}
}
model_calc(Weekly)
getwd()
